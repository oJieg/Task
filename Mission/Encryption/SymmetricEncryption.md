#####Просьба каждого из участников коммитить в *свою* собственную ветку

Требуется:
* Циклическая работа скрипта, до тех пор пока пользователь не напишет `cm:stop` регистр не учитывается
* Запросить у пользователя пароль на "сессию"
	* Под сессией, в данном случае, понимается время работы скрипта, до тех пор пока пользователь, принудительно не остановит выполнение
	* Ввод ключа обозначается командой `cm:psw` регистр не учитывается
	* Ключ сессии может быть любой ненулевой длины
* Декодировать строку указанную пользователем в последовательность/массив байт
* Закодировать/зашифровать последовательноть/массив байт по указанному ниже алгоритму
* Заархивировать полученную после кодирования/шифрования последовательноть/массив байт
* Привести к шестнадцатиричному виду полученную после архивирования последовательноть/массив байт привести к строке, и вывести на экран полученную строку с разбивкой (через каждые **76** символов перенос строки)
* Дать возможность пользователю закодировать/зашифровать еще некоторое количество строк
* Для кодирования строка должна начинаться с `cm:ecd` регистр не учитывается
* Для декодирования строка должна начинаться с `cm:dcd` регистр не учитывается
* В любой момент времени, кроме времени декодирования/кодирования, пользователь может сменить пароль сессии, написав соотвественно `cm:psw` регистр не учитывается
* Скрипт должен отвечать справкой (в которой будет перечислено поддерживаемые команды) на команды:
	* `cm:?` регистр не учитывается
	* `cm:help` регистр не учитывается
	* `cm:man` регистр не учитывается
	
Алгоритм кодирования:

1. На основе введенного пользователем ключа сессии, генерируется рабой-ключ, длинной в  128 байт (в качестве сида рандома используется некоторая связь из ключа-сессии, какая именно - свободное исполнение)
2. Массив байт, полученный из строки делится на строго четыре равные части (допустимо добивать либо последнюю часть нулями с конца, либо первую нулями с начала)
3. Первая и третья часть, шифруюся методом `Xor (^)` причем, байты из частей идут последовательно, **от первого к последнем**, в то же время, в рабочем-ключе **от последнего к первому**
4. Вторая и четвертая часть, так же шифруются методом `Xor (^)` примем, байты из частей идут последовательно, от **последнего к первому**, в то же время, в рабочем-ключе **от первого к последнему**
5. Случайным образом из каждой части перемещается произвольное количество байт в другую случайную часть (пояснение, так рандомом выпадает, что из первой части, будет перенесено десять байт в четвертую часть, так повторяется с каждой частью)
6. Из полученных частей формируется итоговый массив. Части расположены в так же случайном порядке (например может быть порядок 2-1-4-3)

Алгоритм декодирования - аналогичен кодированию, но выполняется в обратном порядке

Допускается:
* Запись результата в файл
* Использование одного инстанса рандома
* Суммарное время выполнения скрипта с кодирование и декодированием не более 250 мс
* В случае введения строки нулевой длины при кодировании или декодировании - выдавать предупреждение и перезапрашивать информацию

#Можно ли использовать готовый модуль base64? или это читерство уже? 
